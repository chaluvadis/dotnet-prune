using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.FindSymbols;
using Microsoft.CodeAnalysis.MSBuild;
using System.Text.Json;

// --- Configure analysis options here (no console args; edit these constants) ---
const string TargetPath = @"C:\Users\schaluvadi\Downloads\FlowCore-developer\FlowCore.slnx"; // <-- set this to your .slnx or .csproj path or folder
const bool IncludePublic = true;
const bool IncludeInternal = true;
const bool ExcludeGenerated = true;
const string ReportPath = @"C:\Users\schaluvadi\Downloads\FlowCore-developer\unused-report.json"; // set to empty string "" to disable writing file

// Top-level program: call an async local RunAsync and return its result.
return await RunAsync(GetOptions());

static JsonSerializerOptions GetOptions() => new() { WriteIndented = true };

static async Task<int> RunAsync(JsonSerializerOptions options)
{
    // Use the constants above instead of reading from console args.
    string targetPath = TargetPath;
    bool includePublic = IncludePublic;
    bool includeInternal = IncludeInternal;
    bool excludeGenerated = ExcludeGenerated;
    string? reportPath = string.IsNullOrEmpty(ReportPath) ? null : ReportPath;

    if (!File.Exists(targetPath) && !Directory.Exists(targetPath))
    {
        Console.WriteLine($"Error: target '{targetPath}' not found.");
        return 2;
    }

    var findings = new List<Finding>();

    // Register MSBuild (required by MSBuildWorkspace)
    MSBuildLocator.RegisterDefaults();

    using var workspace = MSBuildWorkspace.Create(new Dictionary<string, string>()
    {
        // customize workspace properties here if needed
    });

    // Use the new RegisterWorkspaceFailedHandler API (avoids obsolete event)
    using var workspaceFailedRegistration = workspace.RegisterWorkspaceFailedHandler(diagnostic =>
    {
        Console.Error.WriteLine($"Workspace warning: {diagnostic}");
    });

    Console.WriteLine($"Opening '{targetPath}'...");
    Solution solution;
    if (targetPath.EndsWith(".slnx", StringComparison.OrdinalIgnoreCase) || targetPath.EndsWith(".sln", StringComparison.OrdinalIgnoreCase))
    {
        solution = await workspace.OpenSolutionAsync(targetPath);
    }
    else if (targetPath.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase))
    {
        var project = await workspace.OpenProjectAsync(targetPath);
        solution = project.Solution;
    }
    else
    {
        // try to find a .slnx/.sln in current dir, otherwise find csproj inside folder
        var slnCandidate = Directory.GetFiles(Directory.GetCurrentDirectory(), "*.slnx").FirstOrDefault()
                           ?? Directory.GetFiles(Directory.GetCurrentDirectory(), "*.sln").FirstOrDefault();
        if (slnCandidate is null)
        {
            var csprojs = Directory.GetFiles(targetPath, "*.csproj", SearchOption.AllDirectories);
            if (csprojs.Length == 0)
            {
                Console.WriteLine("No .csproj found. Aborting.");
                return 3;
            }
            var firstProject = await workspace.OpenProjectAsync(csprojs.First());
            solution = firstProject.Solution;
        }
        else
        {
            solution = await workspace.OpenSolutionAsync(slnCandidate);
        }
    }

    Console.WriteLine($"Loaded solution: {solution.FilePath ?? "(in-memory)"}");
    Console.WriteLine($"Projects: {solution.Projects.Count()}");

    // Precompute set of project ids that belong to the solution to filter references
    var solutionProjectIds = new HashSet<ProjectId>(solution.Projects.Select(p => p.Id));

    // Compute namespaces declared by the solution (only these namespaces will be analyzed).
    // NOTE: we'll augment these with namespaces discovered from declared types below to avoid missing matches.
    var declaredNamespaces = await GetDeclaredNamespacesFromSolutionAsync(solution);
    Console.WriteLine($"Declared namespaces found by syntax scan: {declaredNamespaces.Count}");

    // Helper utilities
    static Location? GetSourceLocation(ISymbol symbol)
        => symbol.Locations.FirstOrDefault(l => l.IsInSource);

    static (int line, int col) GetLinePosition(Location loc)
    {
        if (loc == null || loc.SourceTree == null) return (-1, -1);
        var pos = loc.GetLineSpan().StartLinePosition;
        return (pos.Line + 1, pos.Character + 1);
    }

    static bool IsGenerated(SyntaxTree? tree)
    {
        if (tree == null) return false;
        var text = tree.GetText();
        var first = text.Lines.Take(5).Select(l => l.ToString()).FirstOrDefault(s => !string.IsNullOrWhiteSpace(s));
        if (first == null) return false;
        var markers = new[] { "<auto-generated", "generated by", "<autogenerated" };
        var low = first.ToLowerInvariant();
        return markers.Any(m => low.Contains(m));
    }

    static bool IsNamespaceAllowed(INamespaceSymbol nsSymbol, HashSet<string> declaredNamespaces)
    {
        // If declaredNamespaces was left intentionally empty (no filtering), allow everything.
        if (declaredNamespaces == null || declaredNamespaces.Count == 0)
            return true;

        // If the type is in the global namespace, allow only if solution declared global types (empty string)
        if (nsSymbol == null || nsSymbol.IsGlobalNamespace)
            return declaredNamespaces.Contains(string.Empty);

        var ns = nsSymbol.ToDisplayString(); // e.g. "MyCompany.Project.Sub"
        if (string.IsNullOrEmpty(ns)) return declaredNamespaces.Contains(string.Empty);

        // Allow if any declared namespace equals the namespace or is a parent (prefix match)
        foreach (var declared in declaredNamespaces)
        {
            if (string.IsNullOrEmpty(declared))
            {
                // declared global namespace doesn't match named namespaces
                continue;
            }

            if (ns.Equals(declared, StringComparison.Ordinal) ||
                ns.StartsWith(declared + ".", StringComparison.Ordinal))
                return true;
        }
        return false;
    }

    // Helper to determine whether a reference location is a source location within one of the solution projects
    bool IsReferenceInSolutionSource(Location loc)
    {
        if (loc == null) return false;
        if (!loc.IsInSource) return false;
        var doc = solution.GetDocument(loc.SourceTree);
        if (doc == null) return false;
        return solutionProjectIds.Contains(doc.Project.Id);
    }

    // New helper: gather declared types from a project by inspecting source documents.
    static async Task<List<INamedTypeSymbol>> GetDeclaredTypesInProjectAsync(Project project)
    {
        var set = new List<INamedTypeSymbol>();
        foreach (var document in project.Documents)
        {
            if (!document.SupportsSyntaxTree) continue;
            var root = await document.GetSyntaxRootAsync();
            if (root == null) continue;
            var model = await document.GetSemanticModelAsync();
            if (model == null) continue;

            // Collect class/struct/interface/enum/record declarations
            var typeNodes = root.DescendantNodes().Where(n =>
                n is ClassDeclarationSyntax ||
                n is StructDeclarationSyntax ||
                n is InterfaceDeclarationSyntax ||
                n is EnumDeclarationSyntax ||
                n is RecordDeclarationSyntax);

            foreach (var node in typeNodes)
            {
                try
                {
                    if (model.GetDeclaredSymbol(node) is not INamedTypeSymbol symbol) continue;
                    if (symbol.IsImplicitlyDeclared) continue;
                    // avoid duplicates
                    if (!set.Any(s => SymbolEqualityComparer.Default.Equals(s, symbol)))
                        set.Add(symbol);
                }
                catch
                {
                    // ignore semantic errors in individual documents
                }
            }
        }
        return set;
    }

    // Build a map of declared types per project (we'll use this to augment declared namespaces and analyze types reliably)
    var projectDeclaredTypes = new Dictionary<Project, List<INamedTypeSymbol>>();
    foreach (var project in solution.Projects)
    {
        var list = await GetDeclaredTypesInProjectAsync(project);
        projectDeclaredTypes[project] = list;

        // Augment declaredNamespaces with the namespaces of these types (ensures we don't miss namespaces)
        foreach (var t in list)
        {
            var ns = t.ContainingNamespace?.ToDisplayString();
            if (string.IsNullOrEmpty(ns))
            {
                declaredNamespaces.Add(string.Empty);
            }
            else
            {
                // add all parent namespace prefixes as well for looser matching
                var parts = ns.Split('.');
                for (int i = 1; i <= parts.Length; i++)
                {
                    var prefix = string.Join(".", parts.Take(i));
                    declaredNamespaces.Add(prefix);
                }
            }
        }
    }

    Console.WriteLine($"Declared namespaces after augmentation: {declaredNamespaces.Count}");

    var projectList = solution.Projects.ToList();
    foreach (var project in projectList)
    {
        Console.WriteLine($"\nAnalyzing project: {project.Name}");
        Compilation? compilation;
        try
        {
            compilation = await project.GetCompilationAsync();
            if (compilation == null)
            {
                Console.WriteLine($"  Could not get compilation for {project.Name}. Skipping.");
                continue;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"  Compilation failed for {project.Name}: {ex.Message}");
            continue;
        }

        // Use declared types from the project's source documents (more reliable than traversing compilation.GlobalNamespace)
        var types = projectDeclaredTypes.TryGetValue(project, out var tlist) ? tlist : [];
        Console.WriteLine($"  Declared types found in project source: {types.Count}");

        foreach (var type in types)
        {
            try
            {
                // Skip types outside the solution-declared namespaces
                if (!IsNamespaceAllowed(type.ContainingNamespace, declaredNamespaces))
                    continue;

                if (type.IsImplicitlyDeclared) continue;

                // Respect visibility options for types
                var tAcc = type.DeclaredAccessibility;
                if (tAcc == Accessibility.Public && !includePublic) continue;
                if (tAcc == Accessibility.Internal && !includeInternal && tAcc != Accessibility.Private) continue;
                if (tAcc == Accessibility.Protected || tAcc == Accessibility.ProtectedOrInternal) continue;

                var defTypeLocs = type.Locations.Where(l => l.IsInSource).ToList();
                if (defTypeLocs.Count == 0) continue; // nothing in source to analyze

                // We'll track whether any member of the type has references inside the solution source.
                bool typeHasReferencedMember = false;

                // Analyze members first and record member-level usage (so we don't mark a type unused if its members are used).
                foreach (var member in type.GetMembers())
                {
                    try
                    {
                        if (member.IsImplicitlyDeclared) continue;

                        var defLoc = GetSourceLocation(member);
                        if (excludeGenerated && defLoc != null && IsGenerated(defLoc.SourceTree)) continue;

                        if (member is IMethodSymbol method)
                        {
                            if (method.MethodKind == MethodKind.PropertyGet || method.MethodKind == MethodKind.PropertySet) continue;
                            if (method.MethodKind == MethodKind.EventAdd || method.MethodKind == MethodKind.EventRemove) continue;
                            if (method.MethodKind == MethodKind.StaticConstructor || method.MethodKind == MethodKind.Constructor) continue;
                            if (method.IsOverride) continue;
                            if (method.ExplicitInterfaceImplementations.Any()) continue;

                            var acc = method.DeclaredAccessibility;
                            if (acc == Accessibility.Public && !includePublic) continue;
                            if (acc == Accessibility.Internal && !includeInternal && acc != Accessibility.Private) continue;
                            if (acc == Accessibility.Protected || acc == Accessibility.ProtectedOrInternal) continue;

                            var entry = compilation!.GetEntryPoint(CancellationToken.None);
                            if (entry != null && SymbolEqualityComparer.Default.Equals(entry, method)) continue;

                            // Find references across the solution but only count references that are in source documents
                            var references = await SymbolFinder.FindReferencesAsync(method, solution);
                            var defLocations = method.Locations.Where(l => l.IsInSource).ToList();
                            int refCount = 0;
                            foreach (var rr in references)
                            {
                                foreach (var loc in rr.Locations)
                                {
                                    if (!IsReferenceInSolutionSource(loc.Location)) continue;

                                    bool isDefinitionLocation = defLocations.Any(d =>
                                        d.SourceTree == loc.Location.SourceTree &&
                                        d.SourceSpan.Equals(loc.Location.SourceSpan));
                                    if (!isDefinitionLocation)
                                        refCount++;
                                }
                            }

                            if (refCount > 0)
                                typeHasReferencedMember = true;

                            if (refCount == 0)
                            {
                                var loc = defLoc;
                                var (line, _) = loc != null ? GetLinePosition(loc) : (-1, -1);
                                findings.Add(new Finding(project.Name, loc?.SourceTree?.FilePath ?? "(generated)", line, "Method", type.ToDisplayString(), method.ToDisplayString(), method.DeclaredAccessibility.ToString(), "No references found in solution source"));
                                Console.WriteLine($"    Unused method: {type.ToDisplayString()}.{method.Name} [{method.DeclaredAccessibility}] at {loc?.SourceTree?.FilePath}:{line}");
                            }

                            // Parameters
                            foreach (var param in method.Parameters)
                            {
                                if (param.RefKind != RefKind.None) continue;

                                var paramRefs = await SymbolFinder.FindReferencesAsync(param, solution);
                                var paramDefLocs = param.Locations.Where(l => l.IsInSource).ToList();
                                int paramRefCount = 0;
                                foreach (var rr in paramRefs)
                                {
                                    foreach (var loc in rr.Locations)
                                    {
                                        if (!IsReferenceInSolutionSource(loc.Location)) continue;

                                        bool isDefLoc = paramDefLocs.Any(d => d.SourceTree == loc.Location.SourceTree && d.SourceSpan.Equals(loc.Location.SourceSpan));
                                        if (!isDefLoc) paramRefCount++;
                                    }
                                }
                                if (paramRefCount == 0)
                                {
                                    var pLoc = paramDefLocs.FirstOrDefault();
                                    var (pline, _) = pLoc != null ? GetLinePosition(pLoc) : (-1, -1);
                                    findings.Add(new Finding(project.Name, pLoc?.SourceTree?.FilePath ?? "(generated)", pline, "Parameter", type.ToDisplayString(), $"{method.ToDisplayString()} :: {param.Name}", method.DeclaredAccessibility.ToString(), "Parameter never referenced in solution source"));
                                    Console.WriteLine($"      Unused parameter: {method.ToDisplayString()} :: {param.Name} at {pLoc?.SourceTree?.FilePath}:{pline}");
                                }
                            }
                        }
                        else if (member is IPropertySymbol prop)
                        {
                            if (prop.IsImplicitlyDeclared) continue;
                            var acc = prop.DeclaredAccessibility;
                            if (acc != Accessibility.Private && !includeInternal && !includePublic) continue;
                            if (prop.IsOverride) continue;
                            if (prop.ExplicitInterfaceImplementations.Any()) continue;

                            var defLocProp = GetSourceLocation(prop);
                            if (excludeGenerated && defLocProp != null && IsGenerated(defLocProp.SourceTree)) continue;

                            var refs = await SymbolFinder.FindReferencesAsync(prop, solution);
                            var defLocs = prop.Locations.Where(l => l.IsInSource).ToList();
                            int refCount = 0;
                            foreach (var rr in refs)
                            {
                                foreach (var loc in rr.Locations)
                                {
                                    if (!IsReferenceInSolutionSource(loc.Location)) continue;

                                    bool isDefinitionLocation = defLocs.Any(d =>
                                        d.SourceTree == loc.Location.SourceTree &&
                                        d.SourceSpan.Equals(loc.Location.SourceSpan));
                                    if (!isDefinitionLocation)
                                        refCount++;
                                }
                            }

                            if (refCount > 0)
                                typeHasReferencedMember = true;

                            if (refCount == 0)
                            {
                                var loc = defLocProp;
                                var (line, _) = loc != null ? GetLinePosition(loc) : (-1, -1);
                                findings.Add(new Finding(project.Name, loc?.SourceTree?.FilePath ?? "(generated)", line, "Property", type.ToDisplayString(), prop.ToDisplayString(), prop.DeclaredAccessibility.ToString(), "No references found in solution source"));
                                Console.WriteLine($"    Unused property: {type.ToDisplayString()}.{prop.Name} [{prop.DeclaredAccessibility}] at {loc?.SourceTree?.FilePath}:{line}");
                            }
                        }
                        else if (member is IFieldSymbol field)
                        {
                            if (field.IsImplicitlyDeclared) continue;
                            var acc = field.DeclaredAccessibility;
                            if (acc != Accessibility.Private && !includeInternal && !includePublic) continue;

                            var defLocField = GetSourceLocation(field);
                            if (excludeGenerated && defLocField != null && IsGenerated(defLocField.SourceTree)) continue;

                            var refs = await SymbolFinder.FindReferencesAsync(field, solution);
                            var defLocs = field.Locations.Where(l => l.IsInSource).ToList();
                            int refCount = 0;
                            foreach (var rr in refs)
                            {
                                foreach (var loc in rr.Locations)
                                {
                                    if (!IsReferenceInSolutionSource(loc.Location)) continue;

                                    bool isDefinitionLocation = defLocs.Any(d =>
                                        d.SourceTree == loc.Location.SourceTree &&
                                        d.SourceSpan.Equals(loc.Location.SourceSpan));
                                    if (!isDefinitionLocation)
                                        refCount++;
                                }
                            }

                            if (refCount > 0)
                                typeHasReferencedMember = true;

                            if (refCount == 0)
                            {
                                var loc = defLocField;
                                var (line, _) = loc != null ? GetLinePosition(loc) : (-1, -1);
                                findings.Add(new Finding(project.Name, loc?.SourceTree?.FilePath ?? "(generated)", line, "Field", type.ToDisplayString(), field.ToDisplayString(), field.DeclaredAccessibility.ToString(), "No references found in solution source"));
                                Console.WriteLine($"    Unused field: {type.ToDisplayString()}.{field.Name} [{field.DeclaredAccessibility}] at {loc?.SourceTree?.FilePath}:{line}");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"    Warning analyzing member {member.Name}: {ex.Message}");
                    }
                } // end members loop

                // After analyzing members, determine whether the type itself is referenced anywhere in the solution's source.
                // Don't report type as unused if any of its members were referenced (type is effectively used).
                if (typeHasReferencedMember)
                    continue;

                // Consider the following kinds as types we want to detect as unused:
                // classes, interfaces, enums, structs (including record structs), and records (record classes).
                bool isRecord = type.IsRecord;
                bool considerType =
                    type.TypeKind == TypeKind.Class ||
                    type.TypeKind == TypeKind.Interface ||
                    type.TypeKind == TypeKind.Enum ||
                    type.TypeKind == TypeKind.Struct ||
                    isRecord;

                if (!considerType)
                    continue;

                // For interfaces, additionally check for implementations in the solution.
                bool foundUsage = false;
                if (type.TypeKind == TypeKind.Interface)
                {
                    // Find implementations (classes/structs that implement this interface)
                    var impls = await SymbolFinder.FindImplementationsAsync(type, solution);
                    foreach (var impl in impls)
                    {
                        // impl may be an INamedTypeSymbol or a member (method) if explicit impls are returned;
                        // check its locations and whether it's in solution source
                        foreach (var loc in impl.Locations)
                        {
                            if (IsReferenceInSolutionSource(loc))
                            {
                                foundUsage = true;
                                break;
                            }
                        }
                        if (foundUsage) break;

                        // For named types, also inspect declaring syntax docs:
                        if (impl is INamedTypeSymbol nt)
                        {
                            var ntDefLocs = nt.Locations.Where(l => l.IsInSource);
                            if (ntDefLocs.Any(l => IsReferenceInSolutionSource(l)))
                            {
                                foundUsage = true;
                                break;
                            }
                        }
                    }
                    if (foundUsage)
                        continue;
                }

                // For classes, check derived classes (subclasses) inside the solution
                if (!foundUsage && type.TypeKind == TypeKind.Class)
                {
                    try
                    {
                        // SymbolFinder has FindDerivedClassesAsync in newer Roslyn versions; if unavailable,
                        // the FindReferencesAsync fallback below will still catch many usages.
                        var derived = await SymbolFinder.FindDerivedClassesAsync(type, solution);
                        foreach (var d in derived)
                        {
                            foreach (var loc in d.Locations)
                            {
                                if (IsReferenceInSolutionSource(loc))
                                {
                                    foundUsage = true;
                                    break;
                                }
                            }
                            if (foundUsage) break;
                        }
                    }
                    catch
                    {
                        // If API not available (older Roslyn), ignore and rely on type references below
                    }
                    if (foundUsage) continue;
                }

                // General type references (variable declarations, cast, typeof, generics, attributes, etc.)
                var typeReferences = await SymbolFinder.FindReferencesAsync(type, solution);
                int typeRefCount = 0;
                foreach (var rr in typeReferences)
                {
                    foreach (var loc in rr.Locations)
                    {
                        if (!IsReferenceInSolutionSource(loc.Location)) continue;

                        // Exclude the type's own declaration locations
                        bool isDefinitionLocation = defTypeLocs.Any(d =>
                            d.SourceTree == loc.Location.SourceTree &&
                            d.SourceSpan.Equals(loc.Location.SourceSpan));
                        if (!isDefinitionLocation)
                            typeRefCount++;
                    }
                }

                // Fallback: do a manual semantic scan if SymbolFinder didn't find any references.
                if (typeRefCount == 0)
                {
                    var manualFound = await ManualSemanticSearchForTypeAsync(type, solution, solutionProjectIds);
                    if (manualFound)
                        typeRefCount = 1;
                }

                if (typeRefCount == 0)
                {
                    var loc = defTypeLocs.FirstOrDefault();
                    var (line, _) = loc != null ? GetLinePosition(loc) : (-1, -1);
                    var kind = isRecord ? "Record" : type.TypeKind.ToString();
                    findings.Add(new Finding(project.Name, loc?.SourceTree?.FilePath ?? "(generated)", line, "Type", type.ToDisplayString(), type.ToDisplayString(), type.DeclaredAccessibility.ToString(), $"No references found in solution source (TypeKind={kind})"));
                    Console.WriteLine($"    Unused type: {type.ToDisplayString()} (Kind={kind}) [{type.DeclaredAccessibility}] at {loc?.SourceTree?.FilePath}:{line}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  Warning analyzing type {type.Name}: {ex.Message}");
            }
        } // end types
    } // end projects

    Console.WriteLine($"\nAnalysis complete. Findings: {findings.Count}");
    if (!string.IsNullOrEmpty(reportPath))
    {
        try
        {
            var json = JsonSerializer.Serialize(findings, options);
            await File.WriteAllTextAsync(reportPath, json);
            Console.WriteLine($"Report written to {reportPath}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to write report: {ex.Message}");
        }
    }
    else
    {
        Console.WriteLine("\nFindings (sample):");
        foreach (var f in findings)
        {
            Console.WriteLine($"{f.Project} | {f.SymbolKind} | {f.ContainingType} | {f.SymbolName} | {f.Accessibility} | {f.FilePath}:{f.Line} => {f.Remarks}");
        }
    }

    Console.WriteLine("\nDone.");
    return 0;
}

/// <summary>
/// Scans all source documents in the solution and returns the set of declared namespace names.
/// - Adds empty string if there are top-level types in the global namespace.
/// - Adds each NamespaceDeclaration and FileScopedNamespace declaration name.
/// </summary>
static async Task<HashSet<string>> GetDeclaredNamespacesFromSolutionAsync(Solution solution)
{
    var set = new HashSet<string>(StringComparer.Ordinal);
    foreach (var project in solution.Projects)
    {
        foreach (var document in project.Documents)
        {
            if (!document.SupportsSyntaxTree) continue;
            var root = await document.GetSyntaxRootAsync();
            if (root == null) continue;

            // File-scoped namespaces
            var fileScoped = root.DescendantNodes().OfType<FileScopedNamespaceDeclarationSyntax>()
                .Select(n => n.Name.ToString().Trim())
                .Where(s => !string.IsNullOrEmpty(s));

            foreach (var ns in fileScoped) set.Add(ns);

            // Normal namespace declarations
            var nsDecls = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Select(n => n.Name.ToString().Trim())
                .Where(s => !string.IsNullOrEmpty(s));

            foreach (var ns in nsDecls) set.Add(ns);

            // If there are top-level type declarations that are not inside a namespace,
            // consider the global namespace present.
            var topLevelTypes = root.DescendantNodes().OfType<BaseTypeDeclarationSyntax>()
                .Where(t => t.Ancestors().OfType<NamespaceDeclarationSyntax>().FirstOrDefault() == null
                            && t.Ancestors().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault() == null);
            if (topLevelTypes.Any())
            {
                set.Add(string.Empty); // represent global namespace with empty string
            }
        }
    }
    return set;
}

/// <summary>
/// Manual semantic search fallback for type usages. Scans documents that contain the simple name and uses the semantic model.
/// </summary>
static async Task<bool> ManualSemanticSearchForTypeAsync(INamedTypeSymbol typeSymbol, Solution solution, HashSet<ProjectId> solutionProjectIds)
{
    var shortName = typeSymbol.Name;
    foreach (var project in solution.Projects)
    {
        foreach (var document in project.Documents)
        {
            if (!document.SupportsSyntaxTree) continue;
            var root = await document.GetSyntaxRootAsync();
            if (root == null) continue;

            // quick textual filter
            var text = root.GetText().ToString();
            if (!text.Contains(shortName)) continue;

            var nameNodes = root.DescendantNodes().OfType<SimpleNameSyntax>()
                                 .Where(n => n.Identifier.ValueText == shortName);
            if (!nameNodes.Any()) continue;

            var model = await document.GetSemanticModelAsync();
            if (model == null) continue;

            foreach (var node in nameNodes)
            {
                try
                {
                    var symbolInfo = model.GetSymbolInfo(node).Symbol;
                    ISymbol? symbol = symbolInfo;
                    if (symbol == null)
                    {
                        var tinfo = model.GetTypeInfo(node).Type;
                        symbol = tinfo;
                    }
                    if (symbol == null) continue;

                    // Compare original definitions to handle constructed generics, etc.
                    var symToCompare = (symbol is IMethodSymbol ms && ms.ReducedFrom != null) ? ms.ReducedFrom : symbol;
                    var target = typeSymbol.OriginalDefinition ?? typeSymbol;
                    if (SymbolEqualityComparer.Default.Equals(symToCompare.OriginalDefinition ?? symToCompare, target))
                    {
                        // ensure this is not the type's own declaration (definition)
                        var defLocs = typeSymbol.Locations.Where(l => l.IsInSource).ToList();
                        bool isDef = defLocs.Any(d => d.SourceTree == node.SyntaxTree && d.SourceSpan.Equals(node.Span));
                        if (!isDef)
                        {
                            // ensure the document belongs to solution projects (filter out metadata-as-source)
                            var doc = solution.GetDocument(node.SyntaxTree);
                            if (doc != null && solutionProjectIds.Contains(doc.Project.Id))
                                return true;
                        }
                    }
                }
                catch
                {
                    // ignore semantic exceptions
                }
            }
        }
    }
    return false;
}
internal record Finding(string Project, string FilePath, int Line, string SymbolKind, string ContainingType, string SymbolName, string Accessibility, string Remarks);